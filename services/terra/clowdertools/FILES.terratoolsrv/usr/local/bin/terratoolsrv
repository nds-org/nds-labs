#!/usr/bin/python

from flask import Flask
from flask.ext import restful
from flask_restful import reqparse, abort, Api, Resource
#from subprocess import call
import os

app = Flask(__name__)
api = restful.Api(app)

parser = reqparse.RequestParser()
parser.add_argument('dataset')
parser.add_argument('user')
parser.add_argument('pw')
parser.add_argument('host')

class DockerLog(restful.Resource):
    def get(self):
        cmd = '/usr/bin/docker logs terratoolsrv'
        print cmd
        logtext = os.popen(cmd).read().rstrip()
        return logtext, 201

class IpyClowder(restful.Resource):
    def get(self, id):
        return {'hello': 'world'}

    def delete(self, id):
        print "DEL: ", id
        cmd = 'docker rm -f -v '+id
        res = os.popen(cmd).read().rstrip()
        print "DEL: "+cmd+" returns: ", res
        return '', 204

    def post(self):
        args = parser.parse_args()
        print "ARGS: ", args

        
        
        #
        #
        # Does Jupyter require the data to be populated before it can start?
        # If not, I feel like this may be a much more simple solution
        #
        # Run a jupyter container
        # cmd = '/usr/bin/kubectl run tool-jupyter --port=8888 --labels=tool=jupyter --image=ndslabs/tool-jupyter --restart=Never'
        #
        # Now, populate it with data via clowder-xfer
        # cmd = '/usr/bin/kubectl exec tool-jupyter -- /usr/local/bin/clowder-xfer '+str(args['dataset'])+' '+str(args['user'])+' '+str(args['pw'])
        #
        # The notebook container should now be running with data... we just need to somehow return its port number
        #
        
        
        
        
        
        #
        # Tool container, create it
        #
        # toolCmd = '/usr/bin/kubectl create pvc'
        #
        toolCmd = "/usr/bin/docker create -P -v /home/jovyan/work/data jupyter/scipy-notebook"
        print "toolCmd: ", toolCmd
        toolContainer = os.popen(toolCmd).read().rstrip()
        print "toolContainer: ", toolContainer

        #
        # Do data xfer container in another container
        #
        # TODO: how do we specify volumes? '--volumes-from '+toolContainer
        # cmd = '/usr/bin/kubectl run clowder-xfer --restart=Never --image=terratoolsrv --command -- /usr/local/bin/clowder-xfer '+str(args['dataset'])+' '+str(args['user'])+' '+str(args['pw'])
        #
        cmd = '/usr/bin/docker run --rm -i --volumes-from '+toolContainer+' terratoolsrv /usr/local/bin/clowder-xfer '+str(args['dataset'])+' '+str(args['user'])+' '+str(args['pw'])    
        print cmd
        dataContainer = os.popen(cmd).read().rstrip()
        print "DC: ", dataContainer

        #
        # Start the tool
        #
        # cmd = '/usr/bin/kubectl run --port=8888 --labels=tool=jupyter --image=jupyter/scipy-notebook --restart=Never'
        #
        cmd = '/usr/bin/docker start '+toolContainer
        print cmd
        dataContainer = os.popen(cmd).read().rstrip()
        print "TOOL ID: " + dataContainer

        #
        # Get the port of the jupyter
        #
        # port = 8888 # TODO: can we reasonably make this assumption?
        # portcmd = 'kubectl get pods -l tool=jupyter -o json | grep podIP | sed 's/[ \ta-zA-Z",:]//g'
        #
        portcmd = "/usr/bin/docker inspect --format '{{(index (index .NetworkSettings.Ports \"8888/tcp\") 0).HostPort}}' " + toolContainer
        print "PCMD:", portcmd
        port = os.popen(portcmd).read().rstrip()
        print 'on port ' + port

        #
        # return URL and ID
        #
        ret = {}
        ret['id'] = toolContainer
        ret['URL'] = args['host']+":"+port 
        print ret
        return ret, 201

api.add_resource(IpyClowder, '/tools/docker/ipython')
api.add_resource(DockerLog, '/logs')

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=int("8080"), debug=True)
