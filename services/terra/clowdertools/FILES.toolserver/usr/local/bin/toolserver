#!/usr/bin/python

import os, json
from flask import Flask, request
from flask.ext import restful
from flask_restful import reqparse, abort, Api, Resource

app = Flask(__name__)
api = restful.Api(app)

id_parser = reqparse.RequestParser()
id_parser.add_argument('id')

post_parser = reqparse.RequestParser()
post_parser.add_argument('dataset') # Clowder download path e.g. "http://0.0.0.0:9000/clowder/api/datasets/<ds_id>/download"
post_parser.add_argument('key') # Clowder key

put_parser = reqparse.RequestParser()
put_parser.add_argument('id') # tool containerID
put_parser.add_argument('dataset') # Clowder download path e.g. "http://0.0.0.0:9000/clowder/api/datasets/<ds_id>/download"
put_parser.add_argument('key') # Clowder key

PORTNUM = "8080"

"""
Allow remote user to get contents of toolserver logs
"""
class DockerLog(restful.Resource):

    def get(self):
        cmd = '/usr/bin/docker logs toolserver'
        logtext = os.popen(cmd).read().rstrip()
        return logtext, 201

"""
Main class for instances of tools
"""
class ToolInstance(restful.Resource):

    def get(self, toolPath):
        """ Get details of running instance """

        args = id_parser.parse_args()
        cfg = config[toolPath]
        containerID = str(args['id'])

        if containerID in instanceAttrs:
            instanceURL = instanceAttrs[containerID]["url"]
        else:
            host = request.url_root[:request.url_root.find(":"+PORTNUM)]
            portCmd = "/usr/bin/docker inspect --format '{{(index (index .NetworkSettings.Ports \""+cfg['mappedPort']+"\") 0).HostPort}}' "+containerID
            instanceURL = host+":"+os.popen(portCmd).read().rstrip()

        return {
            "url": instanceURL,
            "name": cfg["toolName"],
            "description": cfg["description"],
            "api_path": toolPath
        }, 200

    def delete(self, toolPath):
        """ Delete a tool instance """

        args = id_parser.parse_args()

        # Remove container
        cmd = 'docker rm -f -v '+str(args['id'])
        os.popen(cmd).read().rstrip()

        return 204

    def post(self, toolPath):
        """ Create a new instance of requested tool container """

        args = post_parser.parse_args()
        cfg = config[toolPath]
        host = request.url_root[:request.url_root.find(":"+PORTNUM)]

        # Create the tool container
        toolCmd = "/usr/bin/docker create -P -v "+cfg['dataPath']+"/data "+cfg['dockerSrc']
        containerID = os.popen(toolCmd).read().rstrip()
        print "CONTAINER ID: ", containerID

        # Do data transfer container in another container
        xferCmd = '/usr/bin/docker run --rm -i --volumes-from '+containerID+' maxzilla2/toolserver:develop /usr/local/bin/clowder-xfer '+str(args['dataset'])+' '+str(args['key'])+' '+cfg['dataPath']
        os.popen(xferCmd).read().rstrip()

        # Start the tool
        startCmd = '/usr/bin/docker start '+containerID
        os.popen(startCmd).read().rstrip()

        # Get and remap port for tool
        portCmd = "/usr/bin/docker inspect --format '{{(index (index .NetworkSettings.Ports \""+cfg['mappedPort']+"\") 0).HostPort}}' "+containerID
        port = os.popen(portCmd).read().rstrip()

        # Make a record of this container's URL for later reference
        instanceAttrs[containerID] = {
            "url": host+":"+port
        }

        return {
           'id': containerID,
           'URL': host+":"+port
        }, 201

    def put(self, toolPath):
        """ Download another dataset into container """

        args = put_parser.parse_args()

        # Do data transfer container in another container
        xferCmd = '/usr/bin/docker run --rm -i --volumes-from '+str(args['id'])+' maxzilla2/toolserver:develop /usr/local/bin/clowder-xfer '+str(args['dataset'])+' '+str(args['key'])+' '+config[toolPath]['dataPath']
        os.popen(xferCmd).read().rstrip()

        return 204

"""
Main class for tool definitions, pulling necessary config vars from toolconfig.json
"""
class Toolbox(restful.Resource):

    def get(self):
        """ Get a list of eligible tool endpoints that can be called """

        tools = {}
        for toolPath in config.keys():
            tools[toolPath] = {
                "name": config[toolPath]["toolName"],
                "description": config[toolPath]["description"]
            }

        return tools, 201

    def delete(self):
        """ Delete tool endpoint from config file """

        return 204

    def post(self):
        """ Add new tool endpoint to config file """

        return 204

    def put(self):
        """ Update existing tool endpoint in config file """

        return 204


"""
Get configured tools from config file
    Should be a list of definition objects like so:
    [
        "toolPath": {
            "toolName"      Human-readable name of the tool, e.g. to display in selection menus.
            "description"   Brief description of tool for users.
            "dockerSrc"     Container source on dockerhub.
            "dataPath"      Path where uploaded datasets will be downloaded.
            "mappedPort"    This is used to map ports for containers of this type using docker inspect.
        },
        {...},
        {...}
    ]
"""
confFile = open("/usr/local/bin/toolconfig.json")
config = json.load(confFile)
confFile.close()

"""
This is used to store mapping of docker container ID to toolType
If this is erased e.g. in service restart, GET calls by instance id will still return URL.
{
    "containerID": {
        "url"               URL for reaching instance from outside
    }
}
"""
instanceAttrs = {}

# Define endpoints
api.add_resource(Toolbox, '/tools')
api.add_resource(ToolInstance, '/tools/<string:toolPath>')
api.add_resource(DockerLog, '/logs')

if __name__ == '__main__':
    app.run(host="0.0.0.0", port=int(PORTNUM), debug=True)
