description: 'NDS Base Deploy CoreOS cluster on OpenStack
  <raila@illinois.edu> 
'

heat_template_version: '2013-05-23'
outputs:
  discovery_ip:
    description: The IP of the Discovery
    value:
      get_attr: [discovery, first_address]
  master_ip:
    description: The IP of the Kubernetes Master
    value:
      get_attr: [kubernetes_master, first_address]
  minion_ips:
    description: The IP of the Kubernetes Minions
    value:
      get_attr: [kubernetes_minions, first_address]
  overlord_ip:
    description: The IP of the Overlord
    value:
      get_attr: [overlord, first_address]
parameters:
  coreos_image: {default: CoreCloud, description: CoreOS Image, type: string}
  discovery_net_interface: {default: eth0, description: Host network interface for
      which the Discovery node will operate over, type: string}
  flannel_url: {default: 'http://e0c2ab32810737fd07e4-700417495149341ce4d5f2e85f203802.r26.cf1.rackcdn.com/flanneld',
    description: Flannel (0.5.3) Binary URL, type: string}
  flavor:
    constraints:
    - allowed_values: [m1.medium, m1.large, m1.xlarge]
      description: 'Must be a valid flavor

        '
    default: m1.medium
    type: string
  floating-network-id: {description: UUID of the external network., label: Floating
      Network ID, type: string}
  git_command: {default: '/usr/bin/git clone https://github.com/metral/overlord ;
      /usr/bin/git -C overlord checkout -qf 1f37433090ec322df4cdde10ebe6ab7b6387dc8b',
    description: Git repo checkout command, type: string}
  keyname: {description: Name of keypair to be used for compute instance, type: string}
  kubernetes_minion_count:
    constraints:
    - description: Must be between 2 and 12 servers.
      range: {max: 12, min: 1}
    default: 3
    description: Number of CoreOS machines to deploy as Kubernetes Minion
    type: number
  kubernetes_net_interface: {default: eth0, description: Host network interface for
      which Kubernetes' overlay will operate over, type: string}
  private-network-id: {description: UUID of the private network., label: Private Network
      ID, type: string}
  private-subnet-id: {description: UUID of the private subnet., label: Private Subnet
      ID, type: string}
  private_discovery_etcd_version: {default: 2.2.0, description: Version of etcd used
      for Private Discovery node, type: string}
  timeout: {default: 600, description: Wait condition timeout seconds, type: number}
resources:
  coreos_cluster_uuid: {type: 'OS::Heat::RandomString'}
  discovery:
    properties:
      config_drive: 'true'
      flavor: {get_param: flavor}
      image: {get_param: coreos_image}
      key_name: {get_param: keyname}
      name: discovery
      networks:
      - port: {get_resource: discovery_port}
      user_data:
        str_replace:
          params:
            '%discovery_net_interface%': {get_param: discovery_net_interface}
            '%private_discovery_etcd_version%': {get_param: private_discovery_etcd_version}
            '%wc_notify%':
              get_attr: [discovery_wait_handle, curl_cli]
          template: "#cloud-config\nwrite_files:\n  - path: /run/get_discovery_interface_ip.sh\n\
            \    permissions: '0755'\n    content: |\n      #!/bin/bash\n      # Get's\
            \ the IP of the interface that discovery will be\n      # accessible over\n\
            \      DISCOVERY_IF=%discovery_net_interface%\n      /usr/bin/ip -4 addr\
            \ show $DISCOVERY_IF | /usr/bin/awk '/inet/ {print $2}' | /usr/bin/cut\
            \ -d/ -f1 > /run/IP\n      /usr/bin/sed -i 's/^/IP=/' /run/IP\n  - path:\
            \ /run/wcnotify.sh\n    permissions: '0755'\n    content: |\n      #!/bin/bash\n\
            \      %wc_notify% --data-binary '{\"status\": \"SUCCESS\"}'\ncoreos:\n\
            \  update:\n    group: stable\n    reboot-strategy: off\n  units:\n  \
            \  - name: private-discovery-setup.service\n      command: start\n   \
            \   content: |\n        [Unit]\n        After=network-online.target\n\
            \        Requires=network-online.target\n\n        [Service]\n       \
            \ Type=forking\n        ExecStart=/usr/bin/bash /run/get_discovery_interface_ip.sh\n\
            \    - name: private-discovery.service\n      command: start\n      content:\
            \ |\n        [Unit]\n        After=network-online.target private-discovery-setup.service\n\
            \        Requires=network-online.target private-discovery-setup.service\n\
            \n        [Service]\n        EnvironmentFile=/run/IP\n        RestartSec=5s\n\
            \        ExecStartPre=/usr/bin/docker pull quay.io/coreos/etcd:v%private_discovery_etcd_version%\n\
            \        ExecStart=/usr/bin/docker run -d --name discovery \\\n      \
            \    -p 2379:2379 -p 2380:2380 \\\n          -v /usr/share/ca-certificates/:/etc/ssl/certs\
            \ \\\n          --net host quay.io/coreos/etcd:v%private_discovery_etcd_version%\
            \ -name discovery \\\n          -initial-advertise-peer-urls http://${IP}:2380,http://${IP}:7001\
            \ \\\n          -listen-peer-urls http://${IP}:2380,http://${IP}:7001\
            \ \\\n          -initial-cluster discovery=http://${IP}:2380,discovery=http://${IP}:7001\
            \ \\\n          -advertise-client-urls http://${IP}:2379,http://${IP}:4001\
            \ \\\n          -listen-client-urls http://0.0.0.0:2379,http://0.0.0.0:4001\n\
            \    - name: private-discovery-done.service\n      command: start\n  \
            \    content: |\n        # Notifiy wait condition\n        [Unit]\n  \
            \      After=network-online.target private-discovery.service\n       \
            \ Requires=network-online.target private-discovery.service\n\n       \
            \ [Service]\n        ExecStart=/run/wcnotify.sh\n"
      user_data_format: RAW
    type: OS::Nova::Server
  discovery_floatingip:
    properties:
      floating_network_id: {get_param: floating-network-id}
    type: OS::Neutron::FloatingIP
  discovery_floatingip_association:
    properties:
      floatingip_id: {get_resource: discovery_floatingip}
      port_id: {get_resource: discovery_port}
    type: OS::Neutron::FloatingIPAssociation
  discovery_port:
    properties:
      network_id: {get_param: private-network-id}
      security_groups:
      - {get_resource: stack_security}
    type: OS::Neutron::Port
  discovery_wait_condition:
    properties:
      handle: {get_resource: discovery_wait_handle}
      timeout: {get_param: timeout}
    type: OS::Heat::WaitCondition
  discovery_wait_handle: {type: 'OS::Heat::WaitConditionHandle'}
  kubernetes_master:
    properties:
      config_drive: 'true'
      flavor: {get_param: flavor}
      image: {get_param: coreos_image}
      key_name: {get_param: keyname}
      name: kubernetes_master
      networks:
      - port: {get_resource: kubernetes_master_port}
      user_data:
        str_replace:
          params:
            '%discovery%':
              get_attr: [discovery, networks, corekube, 0]
            '%flannel_url%': {get_param: flannel_url}
            '%kubernetes_net_interface%': {get_param: kubernetes_net_interface}
            '%uuid%':
              get_attr: [coreos_cluster_uuid, value]
          template: "#cloud-config\nwrite_files:\n  - path: /run/setup_etcd_cloudinit_conf.sh\n\
            \    permissions: '0755'\n    content: |\n      #!/bin/bash\n\n      ENV=\"\
            /etc/environment\"\n\n      # Test for RW access to $1\n      touch $ENV\n\
            \      if [ $? -ne 0 ]; then\n          echo exiting, unable to modify:\
            \ $ENV\n          exit 1\n      fi\n\n      # Setup environment target\n\
            \      sed -i -e '/^COREOS_PUBLIC_IPV4=/d' \\\n          -e '/^COREOS_PRIVATE_IPV4=/d'\
            \ \\\n          \"${ENV}\"\n\n      # We spin loop until the the IP addresses\
            \ are set\n      function get_ip () {\n          IF=$1\n          IP=\n\
            \          while [ 1 ]; do\n              IP=$(ifconfig $IF | awk '/inet\
            \ / {print $2}')\n              if [ \"$IP\" != \"\" ]; then\n       \
            \           break\n              fi\n              sleep .1\n        \
            \  done\n          echo $IP\n      }\n\n      # Echo results of IP queries\
            \ to environment file as soon as network interfaces\n      # get assigned\
            \ IPs\n      echo COREOS_PUBLIC_IPV4=$(get_ip eth0) >> $ENV # Also assigned\
            \ to same IP\n      echo COREOS_PRIVATE_IPV4=$(get_ip eth0) >> $ENV #eno1\
            \ should be changed to your device name\n      A=`cat /etc/environment\
            \ | grep COREOS_PRIVATE_IPV4 | cut -f2 -d \"=\"`\n      sed -i \"s#=:#=${A}:#g\"\
            \ /run/systemd/system/etcd.service.d/20-cloudinit.conf\n      systemctl\
            \ daemon-reload\n  - path: /run/get_discovery_ip_port.sh\n    permissions:\
            \ '0755'\n    content: |\n      #!/bin/bash\n      # Sets up environment\
            \ file with the discovery node's IP &\n      # port so # that in Overlode's\
            \ template \n      # master-apiserver@.service it can be passed \n   \
            \   # in as an argument \n      /usr/bin/cat /run/systemd/system/etcd.service.d/20-cloudinit.conf\
            \ | /usr/bin/grep -i discovery | /usr/bin/cut -f3 -d\"=\" | /usr/bin/awk\
            \ -F '/v' '{print $1}' > /run/discovery_ip_port\n      /usr/bin/sed -i\
            \ 's/^/DISCOVERY_IP_PORT=/' /run/discovery_ip_port\ncoreos:\n  etcd:\n\
            \    name: kubernetes_master\n    discovery: http://%discovery%:2379/v2/keys/discovery/%uuid%\n\
            \    addr: $private_ipv4:4001\n    peer-addr: $private_ipv4:7001\n  fleet:\n\
            \    public-ip: $private_ipv4\n    metadata: kubernetes_role=master\n\
            \  update:\n    group: stable\n    reboot-strategy: off\n  units:\n  \
            \  - name: setup-etcd-cloudinit-conf.service\n      command: start\n \
            \     runtime: true\n      content: |\n        [Unit]\n        Description=Setup\
            \ environment with private (and public) IP addresses\n\n        [Service]\n\
            \        Type=oneshot\n        RemainAfterExit=yes\n        ExecStart=/run/setup_etcd_cloudinit_conf.sh\n\
            \    - name: etcd.service\n      command: start\n    - name: fleet.service\n\
            \      command: start\n    - name: get_discovery_ip_port.service\n   \
            \   command: start\n      runtime: true\n      content: |\n        # Runs\
            \ get_discovery_ip_port.sh to have discovery IP &\n        # port ready\
            \ for consumption by overlord when creating\n        # the Kubernetes'\
            \ master-api@.service template\n        [Unit]\n        After=network-online.target\n\
            \        Requires=network-online.target\n\n        [Service]\n       \
            \ ExecStart=/usr/bin/bash /run/get_discovery_ip_port.sh\n    - name: flannel-install.service\n\
            \      command: start\n      content: |\n        # Installs flannel\n\
            \        [Unit]\n        After=network-online.target\n        Requires=network-online.target\n\
            \n        [Service]\n        Type=oneshot\n        RemainAfterExit=yes\n\
            \        ExecStart=/usr/bin/wget -N -P /opt/bin %flannel_url%\n      \
            \  ExecStart=/usr/bin/chmod +x /opt/bin/flanneld\n    - name: flannel.service\n\
            \      command: start\n      content: |\n        # Configures & starts\
            \ flannel\n        [Unit]\n        After=network-online.target etcd.service\
            \ flannel-install.service\n        Requires=network-online.target etcd.service\
            \ flannel-install.service\n\n        [Service]\n        ExecStartPre=/usr/bin/etcdctl\
            \ mk /coreos.com/network/config '{\"Network\":\"10.244.0.0/15\", \"Backend\"\
            : {\"Type\": \"vxlan\"}}'\n        ExecStart=/opt/bin/flanneld -iface=%kubernetes_net_interface%\n\
            \        Restart=always\n        RestartSec=5s\n    - name: flannel-env.path\n\
            \      command: start\n      content: |\n        # Ensures flannel env\
            \ vars are set to use with Docker\n        [Path]\n        PathExists=/run/flannel/subnet.env\n\
            \        Unit=docker.service\n    - name: docker.service\n      command:\
            \ start\n      content: |\n        # Starts new docker server that uses\
            \ flannel \n        [Unit]\n        After=flannel-env.path network-online.target\
            \ flannel.service\n        Requires=flannel-env.path network-online.target\
            \ flannel.service\n        Description=Docker Application Container Engine\n\
            \n        [Service]\n        EnvironmentFile=/run/flannel/subnet.env\n\
            \        ExecStartPre=/bin/mount --make-rprivate /\n        ExecStartPre=/usr/bin/systemctl\
            \ kill docker.service\n        ExecStart=/usr/bin/docker -d --bip=${FLANNEL_SUBNET}\
            \ --mtu=${FLANNEL_MTU}\n\n        [Install]\n        WantedBy=multi-user.target\n"
      user_data_format: RAW
    type: OS::Nova::Server
  kubernetes_master_floatingip:
    properties:
      floating_network_id: {get_param: floating-network-id}
    type: OS::Neutron::FloatingIP
  kubernetes_master_floatingip_association:
    properties:
      floatingip_id: {get_resource: kubernetes_master_floatingip}
      port_id: {get_resource: kubernetes_master_port}
    type: OS::Neutron::FloatingIPAssociation
  kubernetes_master_port:
    properties:
      network_id: {get_param: private-network-id}
      security_groups:
      - {get_resource: stack_security}
    type: OS::Neutron::Port
  kubernetes_minions:
    properties:
      count: {get_param: kubernetes_minion_count}
      resource_def:
        properties:
          config_drive: 'true'
          flavor: {get_param: flavor}
          image: {get_param: coreos_image}
          key_name: {get_param: keyname}
          name: kubernetes_minion_%index%
          networks:
          - network: {get_param: private-network-id}
          security_groups:
          - {get_resource: stack_security}
          user_data:
            str_replace:
              params:
                '%discovery%':
                  get_attr: [discovery, networks, corekube, 0]
                '%flannel_url%': {get_param: flannel_url}
                '%kubernetes_net_interface%': {get_param: kubernetes_net_interface}
                '%uuid%':
                  get_attr: [coreos_cluster_uuid, value]
              template: "#cloud-config\nwrite_files:\n  - path: /run/setup_etcd_cloudinit_conf.sh\n\
                \    permissions: '0755'\n    content: |\n      #!/bin/bash\n\n  \
                \    ENV=\"/etc/environment\"\n\n      # Test for RW access to $1\n\
                \      touch $ENV\n      if [ $? -ne 0 ]; then\n          echo exiting,\
                \ unable to modify: $ENV\n          exit 1\n      fi\n\n      # Setup\
                \ environment target\n      sed -i -e '/^COREOS_PUBLIC_IPV4=/d' \\\
                \n          -e '/^COREOS_PRIVATE_IPV4=/d' \\\n          \"${ENV}\"\
                \n\n      # We spin loop until the the IP addresses are set\n    \
                \  function get_ip () {\n          IF=$1\n          IP=\n        \
                \  while [ 1 ]; do\n              IP=$(ifconfig $IF | awk '/inet /\
                \ {print $2}')\n              if [ \"$IP\" != \"\" ]; then\n     \
                \             break\n              fi\n              sleep .1\n  \
                \        done\n          echo $IP\n      }\n\n      # Echo results\
                \ of IP queries to environment file as soon as network interfaces\n\
                \      # get assigned IPs\n      echo COREOS_PUBLIC_IPV4=$(get_ip\
                \ eth0) >> $ENV # Also assigned to same IP\n      echo COREOS_PRIVATE_IPV4=$(get_ip\
                \ eth0) >> $ENV #eno1 should be changed to your device name\n    \
                \  A=`cat /etc/environment | grep COREOS_PRIVATE_IPV4 | cut -f2 -d\
                \ \"=\"`\n      sed -i \"s#=:#=${A}:#g\" /run/systemd/system/etcd.service.d/20-cloudinit.conf\n\
                \      systemctl daemon-reload\ncoreos:\n  etcd:\n    name: kubernetes_minion_%index%\n\
                \    discovery: http://%discovery%:2379/v2/keys/discovery/%uuid%\n\
                \    addr: $private_ipv4:4001\n    peer-addr: $private_ipv4:7001\n\
                \  fleet:\n    public-ip: $private_ipv4\n    metadata: kubernetes_role=minion\n\
                \  update:\n    group: stable\n    reboot-strategy: off\n  units:\n\
                \    - name: setup-etcd-cloudinit-conf.service\n      command: start\n\
                \      runtime: true\n      content: |\n        [Unit]\n        Description=Setup\
                \ environment with private (and public) IP addresses\n\n        [Service]\n\
                \        Type=oneshot\n        RemainAfterExit=yes\n        ExecStart=/run/setup_etcd_cloudinit_conf.sh\n\
                \    - name: etcd.service\n      command: start\n    - name: fleet.service\n\
                \      command: start\n    - name: flannel-install.service\n     \
                \ command: start\n      content: |\n        # Installs flannel\n \
                \       [Unit]\n        After=network-online.target\n        Requires=network-online.target\n\
                \n        [Service]\n        Type=oneshot\n        RemainAfterExit=yes\n\
                \        ExecStart=/usr/bin/wget -N -P /opt/bin %flannel_url%\n  \
                \      ExecStart=/usr/bin/chmod +x /opt/bin/flanneld\n    - name:\
                \ flannel.service\n      command: start\n      content: |\n      \
                \  # Configures & starts flannel\n        [Unit]\n        After=etcd.service\
                \ flannel-install.service\n        Requires=etcd.service flannel-install.service\n\
                \n        [Service]\n        ExecStart=/opt/bin/flanneld -iface=%kubernetes_net_interface%\n\
                \        Restart=always\n        RestartSec=5s\n    - name: flannel-env.path\n\
                \      command: start\n      content: |\n        # Ensures flannel\
                \ env vars are set to use with Docker\n        [Path]\n        PathExists=/run/flannel/subnet.env\n\
                \        Unit=docker.service\n    - name: docker.service\n      command:\
                \ start\n      content: |\n        # Starts new docker server that\
                \ uses flannel\n        [Unit]\n        After=flannel-env.path network-online.target\
                \ flannel.service\n        Requires=flannel-env.path network-online.target\
                \ flannel.service\n        Description=Docker Application Container\
                \ Engine\n\n        [Service]\n        EnvironmentFile=/run/flannel/subnet.env\n\
                \        ExecStartPre=/bin/mount --make-rprivate /\n        ExecStartPre=/usr/bin/systemctl\
                \ kill docker.service\n        ExecStart=/usr/bin/docker -d --bip=${FLANNEL_SUBNET}\
                \ --mtu=${FLANNEL_MTU}\n\n        [Install]\n        WantedBy=multi-user.target\n"
          user_data_format: RAW
        type: OS::Nova::Server
    type: OS::Heat::ResourceGroup
  overlord:
    properties:
      config_drive: 'true'
      flavor: {get_param: flavor}
      image: {get_param: coreos_image}
      key_name: {get_param: keyname}
      name: overlord
      networks:
      - port: {get_resource: overlord_port}
      user_data:
        str_replace:
          params:
            '%discovery%':
              get_attr: [discovery, networks, corekube, 0]
            '%git_command%': {get_param: git_command}
            '%uuid%':
              get_attr: [coreos_cluster_uuid, value]
            '%wc_notify%':
              get_attr: [overlord_wait_handle, curl_cli]
          template: "#cloud-config\nwrite_files:\n  - path: /run/wcnotify.sh\n   \
            \ permissions: '0755'\n    content: |\n      #!/bin/bash\n      %wc_notify%\
            \ --data-binary '{\"status\": \"SUCCESS\"}'\n  - path: /run/setup_etcd_cloudinit_conf.sh\n\
            \    permissions: '0755'\n    content: |\n      #!/bin/bash\n\n      ENV=\"\
            /etc/environment\"\n\n      # Test for RW access to $1\n      touch $ENV\n\
            \      if [ $? -ne 0 ]; then\n          echo exiting, unable to modify:\
            \ $ENV\n          exit 1\n      fi\n\n      # Setup environment target\n\
            \      sed -i -e '/^COREOS_PUBLIC_IPV4=/d' \\\n          -e '/^COREOS_PRIVATE_IPV4=/d'\
            \ \\\n          \"${ENV}\"\n\n      # We spin loop until the the IP addresses\
            \ are set\n      function get_ip () {\n          IF=$1\n          IP=\n\
            \          while [ 1 ]; do\n              IP=$(ifconfig $IF | awk '/inet\
            \ / {print $2}')\n              if [ \"$IP\" != \"\" ]; then\n       \
            \           break\n              fi\n              sleep .1\n        \
            \  done\n          echo $IP\n      }\n\n      # Echo results of IP queries\
            \ to environment file as soon as network interfaces\n      # get assigned\
            \ IPs\n      echo COREOS_PUBLIC_IPV4=$(get_ip eth0) >> $ENV # Also assigned\
            \ to same IP\n      echo COREOS_PRIVATE_IPV4=$(get_ip eth0) >> $ENV #eno1\
            \ should be changed to your device name\n      A=`cat /etc/environment\
            \ | grep COREOS_PRIVATE_IPV4 | cut -f2 -d \"=\"`\n      sed -i \"s#=:#=${A}:#g\"\
            \ /run/systemd/system/etcd.service.d/20-cloudinit.conf\n      systemctl\
            \ daemon-reload\ncoreos:\n  etcd:\n    name: overlord\n    discovery:\
            \ http://%discovery%:2379/v2/keys/discovery/%uuid%\n    addr: $private_ipv4:4001\n\
            \    peer-addr: $private_ipv4:7001\n  update:\n    group: stable\n   \
            \ reboot-strategy: off\n  units:\n    - name: setup-etcd-cloudinit-conf.service\n\
            \      command: start\n      runtime: true\n      content: |\n       \
            \ [Unit]\n        Description=Setup environment with private (and public)\
            \ IP addresses\n\n        [Service]\n        Type=oneshot\n        RemainAfterExit=yes\n\
            \        ExecStart=/run/setup_etcd_cloudinit_conf.sh\n    - name: etcd.service\
            \ \n      command: start\n    - name: fleet.socket\n      command: start\n\
            \      content: |\n        [Socket]\n        # Talk to the API over a\
            \ Unix domain socket (default)\n        ListenStream=/var/run/fleet.sock\n\
            \n        # Talk to the API over an exposed port\n        ListenStream=10001\n\
            \        Service=fleet-local.service\n\n        [Install]\n        WantedBy=sockets.target\n\
            \    - name: fleet-local.service\n      command: start\n      content:\
            \ |\n        # fleet-local is kicked off by fleet.socket after API port\n\
            \        # is opened\n        [Unit]\n        Description=fleet-local\n\
            \        Wants=etcd.service\n        Requires=etcd.service\n\n       \
            \ [Service]\n        Environment=FLEET_PUBLIC_IP=$private_ipv4\n     \
            \   Environment=FLEET_METADATA=kubernetes_role=overlord\n        ExecStart=/usr/bin/fleet\n\
            \        Restart=always\n        RestartSec=10s\n    - name: overlord.service\n\
            \      command: start\n      content: |\n        # Overlord / logic layer\
            \ service to deploy kubernetes to\n        # the cluster\n        [Unit]\n\
            \        After=network-online.target etcd.service\n        Requires=network-online.target\
            \ etcd.service\n\n        [Service]\n        WorkingDirectory=/root\n\
            \        Environment=\"DIR=overlord\"\n        ExecStartPre=/usr/bin/rm\
            \ -rf $DIR\n        ExecStartPre=%git_command%\n        ExecStart=/usr/bin/bash\
            \ ${DIR}/build_run.sh\n    - name: overlord-done.service\n      command:\
            \ start\n      content: |\n        # Notifiy wait condition\n        [Unit]\n\
            \        After=network-online.target overlord.service\n        Requires=network-online.target\
            \ overlord.service\n\n        [Service]\n        ExecStart=/run/wcnotify.sh\n"
      user_data_format: RAW
    type: OS::Nova::Server
  overlord_floatingip:
    properties:
      floating_network_id: {get_param: floating-network-id}
    type: OS::Neutron::FloatingIP
  overlord_floatingip_association:
    properties:
      floatingip_id: {get_resource: overlord_floatingip}
      port_id: {get_resource: overlord_port}
    type: OS::Neutron::FloatingIPAssociation
  overlord_port:
    properties:
      network_id: {get_param: private-network-id}
      security_groups:
      - {get_resource: stack_security}
    type: OS::Neutron::Port
  overlord_wait_condition:
    properties:
      handle: {get_resource: overlord_wait_handle}
      timeout: {get_param: timeout}
    type: OS::Heat::WaitCondition
  overlord_wait_handle: {type: 'OS::Heat::WaitConditionHandle'}
  stack_security:
    properties:
      name: corekube
      rules:
      - {port_range_max: 65535, port_range_min: 0, protocol: tcp, remote_ip_prefix: 0.0.0.0/0}
      - {port_range_max: 65535, port_range_min: 0, protocol: udp, remote_ip_prefix: 0.0.0.0/0}
      - {protocol: icmp, remote_ip_prefix: 0.0.0.0/0}
    type: OS::Neutron::SecurityGroup

  
